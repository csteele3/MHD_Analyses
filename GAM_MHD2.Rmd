---
title: "GAM_MHD"
author: "Christen"
date: "March 25, 2020"
output:
  html_document:
    df_print: paged
---

GAM Work with Monarch Health Data



*Overall Research Question 1*
How do the spatial dynamics of OE infection prevalence change within year and between years in the sedentary population of monarch butterflies in the SE U.S.?




*Why use a GAM?*
We do not expect the patterns in disease prevalence as described by our predictor variables to be linear. For example, infection prevalence may experience increases during periods of warm weather such as in late fall and early spring, while mid winter low temperatures may result in a decline in infection prevalence as population density and therefore transmission potential declines. Graphs of the dataset are provided below for visual inspection of the linear or non-linear trends.  

*Dataset*
```{r}
#wdata <- read.csv("./data/MHD_WD.csv", colClasses = c("Pop_density_CAT" = "factor", "Hardiness2" = "factor", "Infection_Severity" = "factor", "Month"= "factor", "Year"= "factor"))

data<- read.csv("./data/YR_MHD.csv")

```


*Exploration of the Data through Graphing*
Graph the relationship between infection and day of year to visually inspect the relationship for linearity. 
From this figure it is hard to discern any clear pattern. There seems to be a mostly random distribution of infection prevalence across all year (by day of year). 

#Note: Day 200 is mid-July 

Section 1 
```{r}


#Convert variables into different forms for graphing purposes
data$Day_Year<-as.factor(data$Day_Year)
data$Infection<-as.numeric(data$Infection)

library(dplyr)
#Calculate the probability of infection on each day of year 
 library(plyr)
r2<-ddply(data,.(Day_Year), summarize, mean=mean(Infection))
r3<- (r2$mean)
r2$r3 <- r3

library(ggplot2)
ggplot(data=r2, aes(x=as.numeric(Day_Year), r3))+geom_point() + geom_smooth()


ggplot(data=data, aes(x=as.numeric(Day_Year), r3))+geom_point() + geom_smooth()


```

Graph the relationship between infection and year to visually inspect the relationship for linearity. 

Note: Year data is from 2009-2018

Section 2 
```{r}
#Convert variables into different forms for graphing purposes
##data$Season<-revalue(data$Season, c("11_12"="1", "12_13"="2", "13_14"="3", "14_15"="4", "15_16"="5", "16_17"="6", "17_18"="7"))

data$Year.Sampled<-as.factor(data$Year.Sampled)
data$Infection<-as.numeric(data$Infection)


#Calculate the probability of infection on each day of year 
 library(plyr)
s1<-ddply(data,.(Year.Sampled), summarize, mean=mean(Infection))
s2<- (s1$mean)
s1$s2 <- s2

#Plot 
plot(as.numeric(s1$Year.Sampled), s1$
       s2, xlab = "Year", ylab = "Probability of Infection", type='o')
```



*Analyzing the Change in Infection Prevalence Over Time*
  
  *Hypothesis 1: Within Year*
 Within a single winter season/year OE infection prevalence may increase with day of year as reproductive activity and increased monarch density lead to higher rates of transmission. 

  *Target output*: Create a model that analyzes how OE prevalence changes over the course of each individual season/year. 
  Create:
  1) 7 seperate figures, one for each season/year
  
 
  
  *Hypothesis 2: Between Years*
  If the population of winterbreeding monarchs in the southeastern US is growing, we expect that OE infection prevalence may increase with year as increased monarch density leads to higher rates of transmission.
  
  *Target output*: Create a model that analyzes how OE prevalance changes over time (years). 
Create: 
  1) One figure showing the change in infection over all 7 years of data 
  

*Model Construction*
This first model is designed to characterize temporal infection patterns in the southeast by including month, year and an interaction of these two terms in a single model. 

Details on the model:
1. Why "ti"?
  Tensor product smooths are used to model interactions between variables that have different natural scales. They multiply the smooth terms of one variable by the factor levels of the other. 

2. Why "by"?
  "By" variables are used for constructing "varying coefficient models" and for letting smooths interact with parametric terms. In this case our smooth is the Day_Year variable and the Season term is the parametric term (and a factor). 
The interaction between two parametric terms would use the : or * connotation, but smooth interactions cannot. "By" generates an indicator vector for each level of a factor  unless the factor is ordered. If it is ordered then a different smooth is generated for each fator level (except the first level). 


3. Why k=6? 
The term k is also referred to as "knots". These are the natural breaks in the basis functions that make up the "basis" or "smooth function" or "spline". Where the knots break along the spline is usually defined by quantiles. K is usually the max number of degrees of freedom allowed for a smooth term in the model. K in the models will always =  (max degrees of freedom - 1). In this case 

4. Why "family=binomial"? 
The response variable is either 0 (uninfected) or 1 (infected), this we have 2 curves for our response variable distribution and this requires that the model be fit with a binomial family distribution. 

5. Why is "Season" parametric?


6. Why is Volunteer "bs=re"? 
In order to include Volunteer as a random effect, we tell the model to use the random effect basis function to model this variable. This method only applies to mcgv, as a different method is used for gamm. 

7. Why REML? 

8. Should I be using a different basis function? Cubic? 

Section 3 
```{r}
require(mgcv)


#Ensure variables are of the correct type for model construction 
data$Day_Year<-as.numeric(data$Day_Year)
data$Year.Sampled<-as.factor(data$Year.Sampled)

data$Infection<-as.factor(data$Infection)

# Fit model without Year Smoothed 

gam_mod <- gam(Infection ~  Year.Sampled + ti(Day_Year, by = Year.Sampled, k =6) + s(Volunteer, bs="re"), family = binomial, method = "REML", data = data)

summary(gam_mod) 

save(gam_mod, file="gam_mod.Rdata")

##Test the effect of runnign Year.SAmpled as a numeric with GAM_Mod                                                            

#Code below for comparing models# 

###Fit model with year smoothed 

data$Year.Sampled<-as.numeric(data$Year.Sampled)


gam_modSS <- gam(Infection ~  s(Year.Sampled, k = 8) + ti(Day_Year, by = Year.Sampled, k= 8) + s(Volunteer, bs="re"), family = binomial, method = "REML", data = data)

summary(gam_modSS)
save(gam_modSS, file="gam_modSS.Rdata")


###Fit model with Day_Year as individual effect 

#Running Both as numeric variables
data$Year.Sampled<-as.numeric(data$Year.Sampled)
data$Day_Year<-as.numeric(data$Day_Year)


gam_modIY <- gam(Infection ~  s(Day_Year) + s(Year.Sampled, k = 8) + ti(Day_Year, by = Year.Sampled, k= 8) + s(Volunteer, bs="re"), family = binomial, method = "REML", data = data)

save(gam_modIY, file="gam_modIY.Rdata")

summary(gam_modIY)

#Running Year as a Factor 
data$Year.Sampled<-as.factor(data$Year.Sampled)
data$Day_Year<-as.numeric(data$Day_Year)


gam_modIF <- gam(Infection ~  s(Day_Year) + Year.Sampled + ti(Day_Year, by = Year.Sampled, k= 8) + s(Volunteer, bs="re"), family = binomial, method = "REML", data = data)

save(gam_modIF, file="gam_modIY.Rdata")

summary(gam_modIF)

#WHen comparing all 3 models:
#gam_modIF = 12266.17
#gam_modIY = 12813.5. 
#gam_mod = 12317.86
#gam_modSS = 12859.28
AIC(gam_modIY, gam_modIF, gam_mod, gam_modSS)

```
*Summarize output of model*

Section 4
```{r}

#For table 
summary.gam(gam_mod) 

mgcv:summary(gam_mod)

class(gam_mod)

```
Key points from model output: 

The model output summary tells us that the additive temporal variables explain 44.3% of the deviance.We also can convert the outputs from the model to actual probabilities because the GAM model uses a log-odds scale for estimating outputs. After converting the intercept estimate below we find that the model predicts a 65.5% chance of infection overall. 
Section 5 
```{r}
plogis(0.6439)
```


*Checking the Model*

Section 6 
```{r}
#gam.check(gam_mod)

#gam.check does not seem to be the best method for visualizing logistic models

library(arm)

binnedplot(fitted(gam_modIF), 
           residuals(gam_modIF, type = "response"), 
           nclass = NULL, 
           xlab = "Expected Values", 
           ylab = "Average residual", 
           main = "S Year", 
           cex.pts = 0.8, 
           col.pts = 1, 
           col.int = "gray")
```


*Plot the results of the temporal model* 
Plots of the partial effects of the interaction fo Day_Year and Season for each level of Season. 

Section 7 
```{r}
#install.packages("mgcViz")
require(mgcViz)

#Partial effects plots with 95% confidence intervals
  #y axis = Mean sqaure difference between fitted values? If transformed then we get probability 

#Version1: Figures with probabilities along y axis and shifted to incorporate the intercept of each smooth
  #these can be interpreted as the probability of the outcome if all other variables were at their average value. The confidence interval are the range of uncertainty of the probability of the outcome for any values of the variable, holding other variables equal at their average value (this interpretation is fromseWithMean)

plot(gam_modIY, pages = 1, trans = plogis,
     shift = coef(gam_modIY)[1], seWithMean = TRUE, rug = TRUE, shade = TRUE, shade.col = "lightgreen", 
     col = "purple")


#Version2
#b <- getViz(gam_mod, trans = plogis)

#print(plot(b, allTerms = T))
```

Visualization of the interaction between Season and Day_Year in a 3D plot. 

Section 8 
```{r}

vis.gam(gam_modSS, n.grid = 50, theta = 400, phi = 20, ylab = "Day of Year", xlab = "Year", zlab = "",
        ticktype = "detailed", color = "terrain", main = "Interaction between day of year and season")



##theta= rotates the view around horizontally 
##phi = rotates the view vertically 
##n.grid =  controls the number of grid boxes
##z scale = GAM model predictions 

```

Contour plot of Day_year and Season. 

Section 9 
```{r}
vis.gam(gam_modIF,  plot.type = "contour", ylab = "Day_Year", xlab = "Year.Sampled", color = "terrain", main = "Interaction between day of year and season", theme(legend.position = "top"))

vis.gam(x= gam_modIF,plot.type = "contour",color="terrain",theta=-35)  


#Determine what the red lines mean 

source("https://sebastiansauer.github.io/Rcode/logit2prob.R")

GM<-logit2prob(coef(gam_mod))


install.packages("gratia")
install.packages("itsadug")

require(gratia)
draw(gam_modIF, n_contour = 5)

require(itsadug)
pvisgam(gam_mod)

```
```{r}

```


Summary of plot results: 

*Spatio-temporal Model Example* 

Joint models of space and time. 

Should an interaction between space and time be included? This is compared here and the interaction is found to be significant and produces a significantly lower AIC value compared to the non-interaction term model. 

Section 10 
```{r}
data$Year.Sampled<-as.numeric(data$Year.Sampled)


#First, run a model without an interaction between space and time as done in the example. By comparing this model to the model with a space-tie interaction, we will be able to determine the relative importance of the interaction term. 

STno = gam(Infection~ s(Longitude_city,Latitude_city) + s(Year.Sampled, k = 8) + s(Volunteer, bs="re"),
                          data=data,family=binomial,method="REML")

save(STno, file="STno.Rdata")
summary(STno)
plot(STno,scheme=2)


#Now run the model with the interaction term 

STyes = gam(Infection~ s(Longitude,Latitude) + s(Year.Sampled, k = 8)+ ti(Longitude, Latitude, Year.Sampled, d=c(2,1)) + s(Volunteer, bs="re"),
                          data=data,family=binomial,method="REML")
save(STyes, file="STyes.Rdata")
summary(STyes)
plot(STyes,scheme=2)

load("STyes.Rdata")
AIC(STyes)


```
WHile including the interaction term improves the fit of the model, it doesnt make it easy to determine where we are seeing 1) OE hotspots within each year 2) the greatest change in hotspots over time. 

We will next use the "predict" function from mgcv to better visualize the output of the STyes model. 







Graphing of space-time interactions 


Section 12: We need to select a volunteer whose observations represent the average infection prevalence found by all volunteers. To do this, we will first determine the average infection prevalence per volunteer and then select the volunteer whose average is closest to this number. 


```{r}
#First use plyr to calculate the average per volunteer 
library(plyr)
r2<-ddply(data,.(Volunteer), summarize, Avg=mean(Infection))
r2
#We now have a table r2, with the average infection prevalence per volunteer for all 269 volunteers 
```

Section 12A: We can visualize the distribution of infection prevalence per volunteer. 
```{r}
library(ggplot2)
ggplot(data=r2, aes(x=as.factor(Volunteer), Avg)) + geom_point()+ geom_smooth()

hist(r2$Avg)
```
Section 12B: Next we summarize the r2 dataframe to determine the overall mean per volunteer. 
```{r}
summary(r2)

#The mean in 0.4681
```

Section 12C: Select the volunteers with an average closest to the average of 0.4681
```{r}

Average_Volunteers <- r2[r2$Avg >= 0.4 & r2$Avg < 0.5, ]
Average_Volunteers$Differ<-0.4681-Average_Volunteers$Avg
Average_Volunteers

#We find that 2 volunteers Ana Maria Agrusa (13) and Laninda Sande (154) have averages closest to the overall average (0.4615385), therefore we can use either volunteer in the model 
```



```{r}
library("maps")
library("dplyr")
library("ggplot2")
states <- map_data("state")

se_map <- subset(states, region %in% c("florida", "georgia", "louisiana", "alabama", "mississippi", "texas", "south carolina", "oklahoma", "arkansas", "north carolina", "tennessee", "virginia", "kentucky"))%>%
  mutate( Latitude = lat, Longitude= long, order=order)


```

Section 13: We can now move on to creating a grid of predicted infection prevalence using the average observation values of volunteer #13.  
```{r}
data$Latitude<-as.numeric(data$Latitude)
data$Longitude<-as.numeric(data$Longitude)

se_map$Latitude<-as.numeric(se_map$lat)
se_map$Longitude<-as.numeric(se_map$long)

data$Year.Sampled<-as.factor(data$Year.Sampled)

#First we'll create gridded data

predict_infection = expand.grid(
  Latitude= seq(min(data$Latitude), 
                max(data$Latitude),
                length=100),
  Longitude = seq(min(data$Longitude),
                  max(data$Longitude),
                  length=100),
  Volunteer = levels(data$Volunteer)[13],  
  Year.Sampled = seq(2011,2018,by=1))

#head(predict_infection)

#summary(data)
```
```{r}
# This now selects only that data that falls within Florida's border
library("mgcv")
library("rgdal")

predict_infection = predict_infection[with(predict_infection, 
                                          inSide(SE2, Latitude,Longitude)),]


```
Create the Model Fit Column 
```{r}

predict_infection$model_fit = predict(STyes,
                                    predict_infection,type = "response")

```



Graph the Data 

```{r}
library(ggplot2)
library(viridis)
ggplot(aes(Longitude, Latitude, group =group, fill= model_fit),
       data=predict_infection)+
  geom_tile()+
  facet_wrap(~Year.Sampled,nrow=2)+
  scale_fill_viridis("Infection Probability")+
  theme_classic()
data$Volunteer
```

############################################Troubleshooting#################################################
Resolving the tearing of the Map 

1. Try functions similar to inSide 
```{r}
#Reorder columns so that Lat and Long are first 
SE2 <- SE[c("Latitude", "Longitude", "group",
               "order", "region")]


library(rgeos)
predict_infection = predict_infection[with(predict_infection, 
                                          over(predict_infection, SE2)),]

#Fails due to data fram 

  #Try converting SE2 to a spatial object 
library(sf)
SE.sf <- st_as_sf(SE2, coords = c("Longitude", "Latitude"), crs = 4326) 

predict_infection = predict_infection[with(predict_infection, 
                                          over(predict_infection, SE.sf)),]

  #Try different package as a way to use Over to select polygons around points
library(sp)
  #Create a new dataframe with just coordinates from predict_infection
  x<-predict_infection$Latitude 
  y<-predict_infection$Longitude 
  PI_pnts<-cbind(x,y)
 #make a spatial file with predict_infection points 
  pts = SpatialPoints(PI_pnts)
 SE.sf$area<-SE.sf$geometry
 pol = SpatialPolygons(SE.sf)


#Still Fails due to data frame 
 
 
 
 
 
 
 
 
#Re-graph
predict_infection$model_fit = predict(STyes,
                                    predict_infection,type = "response")

ggplot(aes(Longitude, Latitude, group =group, fill= model_fit),
       data=predict_infection)+
  geom_tile()+
  facet_wrap(~Year.Sampled,nrow=2)+
  scale_fill_viridis("Infection Probability")+
  theme_classic()




##MISC Attempts

library(tidyverse)
library(maps)

# get map (as map object)
 
states <- map_data("state")

groups = aggregate(se_map, by = "group")

  
se_map






```


2. Try to dissolve the polygons of the states into 1 polygon (similar to red/blue example)
```{r}

##Cut out state lines, making one large polygon 

##Convert back to dataframe 

  #First create a spatial file with state data 
#Create a new dataframe with just coordinates from predict_infection
libs <- c("rgdal", "maptools", "gridExtra") 
  x<-SE2$Latitude 
  y<-SE2$Longitude 
  SE_pnts<-cbind(x,y)
  SE_PNTS = SpatialPoints(SE_pnts)
  SE_Coords<- coordinates(SE2_poly)
# Generate IDs for grouping
SE.id <- cut(SE_Coords[,1], quantile(SE_Coords[,1]), include.lowest=TRUE)

#Need to convert original SE file to Spatial POlygon File 
#install.packages("FRK")
library(FRK)
SE2_poly<-df_to_SpatialPolygons(SE2, "group", c("Latitude", "Longitude"), CRS())


# Merge polygons by ID
SE.union <- unionSpatialPolygons(SE2_poly, SE.id)

# Plotting
plot(SE2_poly)
plot(SE.union, border = "red", lwd = 2)


###This almost works. You end up with some state borders dissolved, but not all and the projection is wrong. 



```

3. Try Adding in Group after creation of predict_infection

```{r}


##Trying to add group in after the creation of predict_infection 
predict_infection <- predict_infection[order(predict_infection$order),]

predict_infection <- rbind(predict_infection, SE2,by=c("Latitude","Longitude"))

predict_infection$G <- SE$group[match(predict_infection$Latitude,SE$Latitude)]

# This now selects only that data that falls within Florida's border
library("mgcv")
library("rgdal")

predict_infection = predict_infection[with(predict_infection, 
                                          inSide(SE2, Latitude,Longitude)),]
```


3. Try Solving Tearing Graphically 
```{r}
#ggmap use this instead of ggplot 
library(ggplot2)
library(viridis)
ggplot(predict_infection, aes(y = Latitude, x = Longitude, fill= model_fit, group = group))+
  geom_polypath() +
  geom_tile()+
  facet_wrap(~Year.Sampled,nrow=2)

gg <- 
  gg + geom_map(data=us, map=us,
                    aes(x=long, y=lat, map_id=region),
                    fill="#ffffff", color="#ffffff", size=0.15)

ggplot(aes(Longitude, Latitude, group =group, fill= model_fit),
       data=predict_infection)+
  geom_tile()+
  facet_wrap(~Year.Sampled,nrow=2)+
  scale_fill_viridis("Infection Probability")+
  theme_classic()
data$Volunteer

cbind(se_map, loc='1')
se_map$subregion<- se_map$subregion= 1

####################
#Keep map data seperate from Model Data 
arr <- predict_infection %>% 
  add_rownames("region") %>% 
  mutate(group=tolower(region))



gg <-ggplot()
gg <- gg + geom_map(data=se_map, map=se_map,
                    aes(x=long, y=lat, map_id=region),
                    fill="#ffffff", color="#ffffff", size=0.15)
gg <- gg + geom_map(data=arr, map=se_map,
                    aes(Longitude, Latitude, fill=model_fit, map_id=region),
                    color="#ffffff", size=0.15)
gg <- gg + scale_fill_continuous(low='thistle2', high='darkred', 
                                 guide='colorbar')
gg <- gg + labs(x=NULL, y=NULL)
gg <- gg + coord_map("albers", lat0 = 39, lat1 = 45) 
gg <- gg + theme(panel.border = element_blank())
gg <- gg + theme(panel.background = element_blank())
gg <- gg + theme(axis.ticks = element_blank())
gg <- gg + theme(axis.text = element_blank())
gg
#################
ggplot(aes( group =group, fill= ),
      )+
  geom_tile()+
  facet_wrap(~Year.Sampled,nrow=2)+
  scale_fill_viridis("Infection Probability")+
  theme_classic()
data$Volunteer
```


Trying to Solve Tearing Graphically 2 
```{r}
library(sp)
library(maps)
library(maptools)


latlong2state <- function(pointsDF) {
    # Prepare SpatialPolygons object with one SpatialPolygon
    # per state (plus DC, minus HI & AK)
    states <- map("state", fill=TRUE, col="transparent", plot=FALSE)
    IDs <- sapply(strsplit(predict_infection$names, ":"), function(x) x[1])
    states_sp <- map2SpatialPolygons(states, IDs=IDs,
                     proj4string=CRS("+proj=longlat +datum=WGS84"))

    # Convert pointsDF to a SpatialPoints object 
    pointsSP <- SpatialPoints(pointsDF, 
                    proj4string=CRS("+proj=longlat +datum=WGS84"))

    # Use 'over' to get _indices_ of the Polygons object containing each point 
    indices <- over(pointsSP, states_sp)

    # Return the state names of the Polygons object containing each point
    stateNames <- sapply(states_sp@polygons, function(x) x@ID)
    stateNames[indices]
}



latlong2state(testPoints)

x<-predict_infection$Longitude
y<-predict_infection$Latitude
LatLon<-data.frame(x,y)

testPoints <- data.frame(x = c(-90, -120), y = c(44, 44))

##TRY AGAIN 

library(maps)
library(sf)

## Get the states map, turn into sf object
US <- st_as_sf(map("state"))

## Test the function using points in Wisconsin and Oregon
testPoints <- data.frame(x = c(-90, -120), y = c(44, 44))

# Make it a spatial dataframe, using the same coordinate system as the US spatial dataframe
testPoints <- st_as_sf(testPoints, coords = c("x", "y"), crs = st_crs(US))

#.. and perform a spatial join!
st_join(testPoints, US)


         ID        geometry
1 wisconsin  POINT (-90 44)
2    oregon POINT (-120 44)



points <- SpatialPoints(predict_infection)
#SpatialPolygonDataFrame - I'm using a shapefile of UK counties
counties <- readOGR(".", "uk_counties")
#assume same proj as shapefile!
proj4string(points) <- proj4string(counties)
#get county polygon point is in
result <- as.character(over(points, counties)$County_Name)
```
```{r}
summary(SE2)
SE2
library(ggpolypath)
graph<-ggplot(aes(x= Longitude, y=Latitude), data=predict_infection, fill = "red", alpha = .9) + geom_polypath(aes(fill = model_fit, group = G))
graph

#Turn G column to all 0s 

predict_infection[is.na(predict_infection)] <- 0
```





Calculate the difference from year to year 
```{r}
predict_infection$model_change =predict(STyes,
                                      predict_infection%>%mutate(Year.Sampled=Year.Sampled+1),
                                      type = "response") - predict_infection$model_fit 
```

```{r}
ggplot(aes(Longitude, Latitude, fill= model_change),
       data=predict_infection%>% filter(Year.Sampled < 2018))+
  geom_tile()+
  facet_wrap(~Year.Sampled,nrow=2)+
  scale_fill_gradient(low = "white", high = "red", na.value = NA)
```












```{r}
library(tidyr)

#creates new data frame with model fit for each year
pivot_wider(predict_infection, id_cols = c(Longitude_city, Latitude_city), names_from = Year.Sampled, values_from = model_fit)
```



```



















We see a change in years 2, 5, 6, 7, of infection prevalence increasing over Day_Year. Where do we end up with the highest infection prevalence? 

Section 14
```{r}

#Create the background map 

```

Section 15 
```{r}




```




*Research Question 2*
How do the listed exogenous variables impact the spatial dynamics of OE infection prevalence change within year and between years in the sedentary population of monarch butterflies in the SE U.S.?
  1. Human population density 
  2. Monarch larval density 
  3. Temperature 
  4. Precipitation
  

*Environmental Variables Model* 
In the Brown et al. paper, they used the GAMs in the previous step to determine the end of season infection prevalence for each year. They then looked for "bivariate correlations" between these infection prevalences and different environmental variables. 

Can I build a GAM to look at how infection varies with temperature, monarch density and other variables within and between years?


```{r}
#I could use the spatio temporal model to determine where OE is most prevalent. Then use these models to see why it is so prevalent in these locations. 

#Perhaps the question should be more focused - instead "which variables correlate with infection" it should be "which variables best predict the prevalnce of OE during a specific time (like in March when migrants return). THen we could use outputs from the temporal models (infection prevalence in march) as response variables"

Egam_mod <- gam(Infection_Severity ~  Season + ti(sDay_Year, by = Season, k =6) + s(EcoRegionIII) + Pop_density_CAT + s(DP10) + s(TMIN) + s(Volunteer.x, bs="re"), family = binomial, method = "REML", data = data)

#gam_mod <- gam(Infection_Severity ~  Season + ti(sDay_Year, by = Season, k =6) + s(Volunteer.x, bs="re"), family = binomial, method = "REML", data = data)

summary(Egam_mod)

```


*Research Question 3*
How do the observed patterns in infection dynamics differ by sex?
